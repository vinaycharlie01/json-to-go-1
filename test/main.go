package main

import (
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
)

func jsonToGo(jsonStr string, typename string, flatten bool, example bool, allOmitempty bool) (string, error) {
	var data interface{}
	var scope interface{}
	var goCode string
	// var tabs = 0

	seen := make(map[string]bool)
	var stack []interface{}
	var accumulator string
	var innerTabs = 0
	var parent string

	err := json.Unmarshal([]byte(jsonStr), &data)
	if err != nil {
		return "", err
	}
	scope = data

	typename = format(typename)
	append("type " + typename + " ")

	parseScope(scope, &goCode, &seen, &stack, &accumulator, &innerTabs, &parent)

	if flatten {
		goCode += accumulator
	}

	return goCode, nil
}

func format(name string) string {
	// Add your own formatting logic here if needed
	return name
}

func append(value string) {
	// Replace this with your own logic to append the value to the generated Go code
	fmt.Print(value)
}

func parseScope(scope interface{}, goCode *string, seen *map[string]bool, stack *[]interface{}, accumulator *string, innerTabs *int, parent *string) {
	// Add your logic to parse the JSON scope and generate Go code here
	// Replace the following print statements with your own code

	fmt.Println("Parsing scope:", scope)
	fmt.Println("Generated Go code:", *goCode)
	fmt.Println("Seen:", *seen)
	fmt.Println("Stack:", *stack)
	fmt.Println("Accumulator:", *accumulator)
	fmt.Println("InnerTabs:", *innerTabs)
	fmt.Println("Parent:", *parent)
}

func ToProperCase(str string) string {
	// Ensure that the SCREAMING_SNAKE_CASE is converted to snake_case
	if match, _ := regexp.MatchString("^[_A-Z0-9]+$", str); match {
		str = strings.ToLower(str)
	}

	// List of common initialisms
	commonInitialisms := map[string]bool{
		"ACL": true, "API": true, "ASCII": true, "CPU": true, "CSS": true, "DNS": true,
		"EOF": true, "GUID": true, "HTML": true, "HTTP": true, "HTTPS": true, "ID": true,
		"IP": true, "JSON": true, "LHS": true, "QPS": true, "RAM": true, "RHS": true,
		"RPC": true, "SLA": true, "SMTP": true, "SQL": true, "SSH": true, "TCP": true,
		"TLS": true, "TTL": true, "UDP": true, "UI": true, "UID": true, "UUID": true,
		"URI": true, "URL": true, "UTF8": true, "VM": true, "XML": true, "XMPP": true,
		"XSRF": true, "XSS": true,
	}

	// Convert the string to Proper Case
	re := regexp.MustCompile(`(^|[^a-zA-Z])([a-z]+)`)
	str = re.ReplaceAllStringFunc(str, func(match string) string {
		parts := re.FindStringSubmatch(match)
		sep, frag := parts[1], parts[2]

		if commonInitialisms[strings.ToUpper(frag)] {
			return sep + strings.ToUpper(frag)
		} else {
			return sep + strings.ToUpper(frag[0:1]) + strings.ToLower(frag[1:])
		}
	})

	re = regexp.MustCompile(`([A-Z])([a-z]+)`)
	str = re.ReplaceAllStringFunc(str, func(match string) string {
		parts := re.FindStringSubmatch(match)
		sep, frag := parts[1], parts[2]

		if commonInitialisms[sep+strings.ToUpper(frag)] {
			return (sep + frag)[0:]
		} else {
			return sep + frag
		}
	})

	return str
}

func main() {
	// jsonStr := `{"example": {"field1": 123, "field2": "hello"}}`
	// typename := "AutoGenerated"
	// flatten := true
	// example := false
	// allOmitempty := false

	// goCode, err := jsonToGo(jsonStr, typename, flatten, example, allOmitempty)
	// if err != nil {
	// 	fmt.Println("Error:", err)
	// 	return
	// }

	fmt.Println("Generated Go code:", goCode)
}
