




	// Sanitizes and formats a string to make an appropriate identifier in Go
	function format(str) {
		str = formatNumber(str);

		let sanitized = toProperCase(str).replace(/[^a-z0-9]/ig, "")
		if (!sanitized) {
			return "NAMING_FAILED";
		}

		// After sanitizing the remaining characters can start with a number.
		// Run the sanitized string again trough formatNumber to make sure the identifier is Num[0-9] or Zero_... instead of 1.
		return formatNumber(sanitized)
	}


// Adds a prefix to a number to make an appropriate identifier in Go
function formatNumber(str) {
    if (!str)
        return "";
    else if (str.match(/^\d+$/))
        str = "Num" + str;
    else if (str.charAt(0).match(/\d/)) {
        const numbers = {
            '0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
            '4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
            '8': "Eight_", '9': "Nine_"
        };
        str = numbers[str.charAt(0)] + str.substr(1);
    }

    return str;
}


function toProperCase(str) {
    // ensure that the SCREAMING_SNAKE_CASE is converted to snake_case
    if (str.match(/^[_A-Z0-9]+$/)) {
        str = str.toLowerCase();
    }

    // https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810
    const commonInitialisms = [
        "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
        "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
        "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
        "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
    ];

    return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function (unused, sep, frag) {
        if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
            return sep + frag.toUpperCase();
        else
            return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
    }).replace(/([A-Z])([a-z]+)/g, function (unused, sep, frag) {
        if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
            return (sep + frag).toUpperCase();
        else
            return sep + frag;
    });
}




function formatScopeKeys(keys) {
    for (let i in keys) {
        keys[i] = format(keys[i]);
    }
    return keys;
}

// // Example usage
// const inputKeys = ['key1', 'key2', 'key3'];
// const formattedKeys = formatScopeKeys(inputKeys);

// console.log(formattedKeys);


function compareObjectKeys(itemAKeys, itemBKeys) {
    const lengthA = itemAKeys.length;
    const lengthB = itemBKeys.length;

    // nothing to compare, probably identical
    if (lengthA == 0 && lengthB == 0)
        return true;

    // duh
    if (lengthA != lengthB)
        return false;

    for (let item of itemAKeys) {
        if (!itemBKeys.includes(item))
            return false;
    }
    return true;
}


function getOriginalName(unique) {
    const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
    const uuidLength = 36;

    if (unique.length >= uuidLength) {
        const tail = unique.substr(-uuidLength);
        if (reLiteralUUID.test(tail)) {
            return unique.slice(0, -1 * (uuidLength + 1))
        }
    }
    return unique
}


function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}



// Given two types, returns the more specific of the two
function mostSpecificPossibleGoType(typ1, typ2) {
    if (typ1.substr(0, 5) == "float"
        && typ2.substr(0, 3) == "int")
        return typ1;
    else if (typ1.substr(0, 3) == "int"
        && typ2.substr(0, 5) == "float")
        return typ2;
    else
        return "any";
}


// // Example usage
// var type1 = "float32";
// var type2 = "int64";

// var result = mostSpecificPossibleGoType(type1, type2);

// console.log("The more specific type is:", result);




function jsonToGo(json, typename, flatten = true, example = false, allOmitempty = false) {
	let data;
	let scope;
	let go = "";
	let tabs = 0;

	const seen = {};
	const stack = [];
	let accumulator = "";
	let innerTabs = 0;
	let parent = "";

	try {
		data = JSON.parse(json.replace(/(:\s*\[?\s*-?\d*)\.0/g, "$1.1")); // hack that forces floats to stay as floats
		scope = data;
	}
	catch (e) {
		return {
			go: "",
			error: e.message
		};
	}

	typename = format(typename || "AutoGenerated");
	append(`type ${typename} `);

	parseScope(scope);
	return {
		go: flatten
			? go += accumulator
			: go
	};

    function parseScope(scope, depth = 0) {
		if (typeof scope === "object" && scope !== null) {
			if (Array.isArray(scope)) {
				let sliceType;
				const scopeLength = scope.length;

				for (let i = 0; i < scopeLength; i++) {
					const thisType = goType(scope[i]);
					if (!sliceType)
						sliceType = thisType;
					else if (sliceType != thisType) {
						sliceType = mostSpecificPossibleGoType(thisType, sliceType);
						if (sliceType == "any")
							break;
					}
				}

				const slice = flatten && ["struct", "slice"].includes(sliceType)
					? `[]${parent}`
					: `[]`;

				if (flatten && depth >= 2)
					appender(slice);
				else
					append(slice)
				if (sliceType == "struct") {
					const allFields = {};

					// for each field counts how many times appears
					for (let i = 0; i < scopeLength; i++) {
						const keys = Object.keys(scope[i])
						for (let k in keys) {
							let keyname = keys[k];
							if (!(keyname in allFields)) {
								allFields[keyname] = {
									value: scope[i][keyname],
									count: 0
								}
							}
							else {
								const existingValue = allFields[keyname].value;
								const currentValue = scope[i][keyname];

								if (compareObjects(existingValue, currentValue)) {
									const comparisonResult = compareObjectKeys(
										Object.keys(currentValue),
										Object.keys(existingValue)
									)
									if (!comparisonResult) {
										keyname = `${keyname}_${uuidv4()}`;
										allFields[keyname] = {
											value: currentValue,
											count: 0
										};
									}
								}
							}
							allFields[keyname].count++;
						}
					}

					// create a common struct with all fields found in the current array
					// omitempty dict indicates if a field is optional
					const keys = Object.keys(allFields), struct = {}, omitempty = {};
					for (let k in keys) {
						const keyname = keys[k], elem = allFields[keyname];

						struct[keyname] = elem.value;
						omitempty[keyname] = elem.count != scopeLength;
					}
					// parseStruct(depth + 1, innerTabs, struct, omitempty); // finally parse the struct !!
				}
				else if (sliceType == "slice") {
					parseScope(scope[0], depth)
				}
				else {
					if (flatten && depth >= 2) {
						appender(sliceType || "any");
					} else {
						append(sliceType || "any");
					}
				}
			}
			else {
				if (flatten) {
					if (depth >= 2) {
						appender(parent)
					}
					else {
						append(parent)
					}
				}
				// parseStruct(depth + 1, innerTabs, scope);
			}
		}
		else {
			if (flatten && depth >= 2) {
				appender(goType(scope));
			}
			else {
				append(goType(scope));
			}
		}
	}

    function compareObjects(objectA, objectB) {
		const object = "[object Object]";
		return Object.prototype.toString.call(objectA) === object
			&& Object.prototype.toString.call(objectB) === object;
	}


    function appender(str) {
		stack[stack.length - 1] += str;
	}

    function append(str) {
        go += str;
    }
    

}



const jsonInput = '{"name": "John", "age": 30, "city": "New York"}';
const typename = "Person";
const result = jsonToGo(jsonInput, typename, true, false, false);

console.log(result.go);



// // Example usage
// const generatedUUID = uuidv4();
// console.log(generatedUUID);



// const input1 = "exampleName-123e4567-e89b-12d3-a456-426614174000";
// const input2 = "anotherName";

// const result1 = getOriginalName(input1);
// const result2 = getOriginalName(input2);

// console.log(result1); // Should print "exampleName"
// console.log(result2); // Should print "anotherName"



// // Example 1: Arrays with the same keys
// const keys1 = ['name', 'age', 'gender'];
// const keys2 = ['name', 'age', 'gender'];

// console.log(compareObjectKeys(keys1, keys2)); // Output: true

// // Example 2: Arrays with different order but same keys
// const keys3 = ['age', 1, 'name'];
// const keys4 = ['name', 'age', 1];

// console.log(compareObjectKeys(keys3, keys4)); // Output: true

// // Example 3: Arrays with different keys
// const keys5 = ['name', 'age', 'gender'];
// const keys6 = ['name', 'occupation', 'gender'];

// console.log(compareObjectKeys(keys5, keys6)); // Output: false




// const inputs = [
//     "some identifier",
//     "another-identifier",
//     "123Identifier",
//     "!@#Special$%^Chars",
//     "CamelCaseIdentifier",
//     "1InvalidIdentifier"
// ];

// inputs.forEach(input => {
//     const result = format(input);
//     console.log(`Input: ${input} => Output: ${result}`);
// });